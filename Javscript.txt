=GIT password - Kumar@7841029556
capgemini psw - Kumar@7841029556
http://www.glarustech.com/careers.html
https://www.avestantechnologies.com/career.html
https://hexalytics.com/#bigdata
https://genpact.taleo.net/careersection/iam/accessmanagement/login.jsf?redirectionURI=https%3A%2F%2Fgenpact.taleo.net%2Fcareersection%2Fsgy_external_career_section%2Fjobapply.ftl%3Fjob%3DITO071879&TARGET=https%3A%2F%2Fgenpact.taleo.net%2Fcareersection%2Fsgy_external_career_section%2Fjobapply.ftl%3Fjob%3DITO071879
https://www.capgemini.com/in-en/careers/
https://careers.valethi.com/jobs/Careers/57485000003130324/Senior-Developer--Software?source=CareerSite
https://github.com/akashyap2013/MERN_Login_App_with_ResetEmail
https://career.infosys.com/joblist?type=ALL&countrycode=IN&companyhiringtype=IL
https://krb-sjobs.brassring.com/TGnewUI/Search/Home/Home?partnerid=26059&siteid=5016#home
https://whataboutcoding.com/redux-toolkit-tutorial/
https://react-redux.js.org/introduction/getting-started
https://redux.js.org/tutorials/quick-start

What is javascript 

Ans : javascript is interpreted client side,event bases object oriented programming language
      JavaScript is a text-based programming language used both on the client-side and server-side .
      JavaScript was developed by Brendan Eich in 1995, which appeared in Netscape, a popular browser of that time.
      javascript is casesensitive language
      javascript is a synchronus & single thread	
Advantage of javascript

Speed
Reduces load on the server
Ease of use
Rich Interface
Versatility
Extended functionality
Interoperability
Popularity
Platform independence
Powerful frameworks
Procedural programming features
Response to user activity
Updates

Features of javascript

Light Weight Scripting language

Dynamic Typing

Object-oriented programming support

Functional Style

Platform Independent

Prototype-based

Interpreted Language

Async Processing

Client-Side Validation

More control in the browser

Data types in javascript 
There are two types of data
1. Primitive data types 
2. Non primitive data types
1.primitive Data types - it is holding only one values 

String
null
number 
undefined
Bigint
Boolean

2. Non primitive data types - it is holding more than one values is called non primitive 

Objects 
Array

Diffrence b/w null & undefined

Undefined - Undefined means a variable has been declared but has yet not been assigned a value.

ex - var abc 

null - null is an assignment value. It can be assigned to a variable as a representation of no value. 
null is a special value that represents an empty or unknown value. 

Ex - let abc = null;

Variable in javascript

Ans - There are 3 ways to declare a JavaScript variable:

	Using var
	Using let
	Using const

Names can contain letters, digits, underscores, and dollar signs.

var declarations are globally scoped or function/locally scoped.
var is function scoped when it is declared within a function. 
This means that it is available and can be accessed only within that function.

let
A block is a chunk of code bounded by {}. A block lives in curly braces. Anything within curly braces is a block.

Variables defined with let cannot be Redeclared.
Variables defined with let must be Declared before use.

Variables defined with let have Block Scope. 

Const  - can not assign the value again

Note - javascript is a case sensitive langage 
https://www.scaler.com/topics/javascript/difference-between-var-let-and-const/

javascript operaters

Javascript Arthematic operator;	

Operator	Description
+	        Addition
-	        Subtraction
*	        Multiplication
**	        Exponentiation (ES2016)
/	        Division
%	        Modulus (Division Remainder)
++	        Increment
--	        Decrement  

JavaScript Comparison Operators

Operator	Description
==	equal to
===	equal value and equal type
!=	not equal
!==	not equal value or not equal type
>	greater than
<	less than
>=	greater than or equal to
<=	less than or equal to
?	ternary operator

JavaScript Logical Operators

Operator	Description
&&	logical and
||	logical or
!	logical not

JavaScript Type Operators

Operator	Description
typeof	Returns the type of a variable
instanceof	Returns true if an object is an instance of an object type

JavaScript Bitwise Operators

Operator Description	
&	AND	
|	OR	
~	NOT	
^	XOR	
<<	left shift	
>>	right shift	
>>>	unsigned right shift	

Expalin switch statements

The switch statement executes a block of code depending on different cases.

The switch statement is a part of JavaScript's "Conditional" Statements, which are used to perform different actions based on different conditions. 
Use switch to select one of many blocks of code to be executed. This is the perfect solution for long, nested if/else statements.

The switch statement evaluates an expression. The value of the expression is then compared with the values of each case in the structure.
 If there is a match, the associated block of code is executed.

The switch statement is often used together with a break or a default keyword (or both). These are both optional:

The break keyword breaks out of the switch block. This will stop the execution of more execution of code and/or case testing inside the block.
 If break is omitted, the next code block in the switch statement is executed.

The default keyword specifies some code to run if there is no case match.
There can only be one default keyword in a switch. Although this is optional, it is recommended that you use it, as it takes care of unexpected cases.

Syntax
switch(expression) {
  case n:
    code block
    break;
  case n:
    code block
    break;
  default:
    default code block
}

Explain if else statments

The if/else statement executes a block of code if a specified condition is true. If the condition is false, another block of code can be executed.

The if/else statement is a part of JavaScript's "Conditional" Statements, which are used to perform different actions based on different conditions.

In JavaScript we have the following conditional statements:

Use if to specify a block of code to be executed, if a specified condition is true
Use else to specify a block of code to be executed, if the same condition is false
Use else if to specify a new condition to test, if the first condition is false
Use switch to select one of many blocks of code to be executed

Syntax

The if statement specifies a block of code to be executed if a condition is true:

if (condition) {
  // block of code to be executed if the condition is true
}
The else statement specifies a block of code to be executed if the condition is false:

if (condition) {
  // block of code to be executed if the condition is true
} else {
  // block of code to be executed if the condition is false
}
The else if statement specifies a new condition if the first condition is false:

if (condition1) {
  // block of code to be executed if condition1 is true
} else if (condition2) {
  // block of code to be executed if the condition1 is false and condition2 is true
} else {
  // block of code to be executed if the condition1 is false and condition2 is false
}
Expain loops 

The JavaScript loops are used to iterate the piece of code using for, while, do while or for-in loops. It makes the code compact. It is mostly used in array.

There are four types of loops in JavaScript.

for loop

The JavaScript for loop iterates the elements for the fixed number of times. It should be used if number of iteration is known. The syntax of for loop is given below.

for (initialization; condition; increment)  
{  
    code to be executed  
}  

while loop

The JavaScript while loop iterates the elements for the infinite number of times. It should be used if number of iteration is not known. The syntax of while loop is given below.

while (condition)  
{  
    code to be executed  
}  


do-while loop 

The JavaScript do while loop iterates the elements for the infinite number of times like while loop. But, 
code is executed at least once whether condition is true or false. The syntax of do while loop is given below.

do{  
    code to be executed  
}while (condition);

for-in loop

Expain string & its method


1.slice(start, end) - 

slice() extracts a part of a string and returns the extracted part in a new string.

The method takes 2 parameters: start position, and end position (end not included).

2.substring(start, end)

substring() is similar to slice().

The difference is that start and end values less than 0 are treated as 0 in substring().

3.substr(start, length) 

substr() is similar to slice().

The difference is that the second parameter specifies the length of the extracted part.

1.charAt() - It provides the char value present at the specified index.
Ex- var str="Javatpoint";
   document.writeln(str.charAt(4));
 o/p - t
2. charCodeAt() - It provides the Unicode value of a character present at the specified index.
3.concat() -It provides a combination of two or more strings.

4.length - The length property returns the length of a string:
5.replace - The replace() method replaces a specified value with another value in a string:
ex - let text = "Please visit Microsoft!";
let newText = text.replace("Microsoft", "W3Schools");
The replace() method does not change the string it is called on.

The replace() method returns a new string.

The replace() method replaces only the first match

If you want to replace all matches, use a regular expression with the /g flag set. See examples below.

By default, the replace() method replaces only the first match:

6. replaceAll - The replaceAll() method allows you to specify a regular expression instead of a string to be replaced.
7.toUpperCase -A string is converted to upper case with toUpperCase():
8.toLowerCase - A string is converted to lower case with toLowerCase():
9.trim() - The trim() method removes whitespace from both sides of a string:
10.trimStart() - The trimStart() method works like trim(), but removes whitespace only from the start of a string.
11.trimEnd() - The trimEnd() method works like trim(), but removes whitespace only from the end of a string.
12.split - A string can be converted to an array with the split() method:

String search method() - 

1.indexOf()-It provides the position of a char value present in the given string.

2.lastIndexOf() -It provides the position of a char value present in the given string by searching a character from the last position.

3 search()-It searches a specified regular expression in a given string and returns its position if a match occurs.	
ex- var str="JavaScript is a scripting language. Scripting languages are often interpreted";
document.writeln(str.search("scripting"));
o/p - 16

Expalin pass by value pass by reference

Pass by value - Pass by value work with primmitve data types
Any changes made to the parameter it will not affect the original value.

ex - let a = 5;              ex - let a = 5;  
     let b = a  		let b = a+5  

cosole.log(a) //5           cosole.log(a) //5
console.log(b) //5          console.log(b) //10

			or 

When you pass a primitive value as an argument to a function,
a copy of that value is created and passed to the function.
Any changes made to the parameter inside the function will not affect the original value outside the function

ex - 

function modifyPrimitive(value) {
  value = 42; // This change won't affect the original value outside the function.
}

let num = 10;
modifyPrimitive(num);
console.log(num); // Output: 10



Pass by reference - Pass by refrence work with non primitive data types

you are actually passing a reference to the memory location where the object is stored. 
This means that any modifications made to the object inside the function will affect the original object outside the function.
ex -1
 let obj1 = {
"name" : "chandu,
"psw"  : "12345"
}

let obj2 = obj1

console.log(obj1) // o/p {
"name" : "chandu,
"psw"  : "12345"
}
console.log(obj2) //o/p
 {
"name" : "chandu,
"psw"  : "12345"
}

ex-2 
 let obj1 = {
"name" : "chandu,
"psw"  : "12345"
}

let obj2 = obj1

obj2.psw ="67890"

console.log(obj1) // o/p {
"name" : "chandu,
"psw"  : "67890"
}
console.log(obj2) //o/p
 {
"name" : "chandu,
"psw"  : "67890"
}
ex -3

function modifyArray(arr) {
  arr.push(4); // This change will affect the original array outside the function.
}

let myArray = [1, 2, 3];
modifyArray(myArray);
console.log(myArray); // Output: [1, 2, 3, 4]

Expalin Es5 features

1. Use Strict - it is pointed the undefined variable with function or without function

syntax - "use strict"

2. trim() - it is ues to use remove white spaces

3. isArray() - 

4. forEach() - 

5. Array map() -

Explain apply call & bind
call ,apply ,bind are predefined method in javascript

call - call method helps us to changes the context of invoking function

call method allows an object to use method of another object

call methods is used for commas seperated

ex 1 . 

const persion1 = {
  "fName" : "chandu",
  "lName" : "kumar",
  fullName : function(){
    return this.fName + " " +this.lName
    
  }
    
}
const persion2 = {
  "fName" : "Suman",
  "lName" : "kri"
}
let result = persion1.fullName.call(persion2)
console.log(result) 

ex -2 

const persion1 = {
  "fName" : "chandu",
  "lName" : "kumar",
  fullName : function(hometown,country){
    return this.fName + " " +this.lName + " " + hometown + " " + country
    
  }
    
}
const persion2 = {
  "fName" : "Suman",
  "lName" : "kri"
}
let result = persion1.fullName.call(persion2,"pune","India")
console.log(result)

apply - call & apply method both are same but in a apply method data passed in a array

ex- 
const persion1 = {
  "fName" : "chandu",
  "lName" : "kumar",
  fullName : function(hometown,country){
    return this.fName + " " +this.lName + " " + hometown + " " + country
    
  }
    
}
const persion2 = {
  "fName" : "Suman",
  "lName" : "kri"
}
let result = persion1.fullName.apply(persion2,["pune","India"])
console.log(result)

bind () - bind metod is same as a call method only differenc is that bind method bind object in a function & returns a  function 
it is create a copy of function 

const persion1 = {
  "fName" : "chandu",
  "lName" : "kumar",
  fullName : function(hometown,country){
    return this.fName + " " +this.lName + " " + hometown + " " + country
    
  }
    
}
const persion2 = {
  "fName" : "Suman",
  "lName" : "kri"
}
let result = persion1.fullName.bind(persion2,"pune","India")
console.log(result())

Explain Hoisting in javascript

Hoisting is the default behaviour of javascript where all the variable and function declarations are moved on top.

Ex-1 

hoistedVariable = 3;
console.log(hoistedVariable); // outputs 3 even when the variable is declared after it is initialized	
var hoistedVariable;

ex-2 

hoistedFunction();  // Outputs " Hello world! " even when the function is declared after calling

function hoistedFunction(){ 
  console.log(" Hello world! ");
} 

Note - Variable initializations are not hoisted, only variable declarations are hoisted:

var x;
console.log(x); // Outputs "undefined" since the initialization of "x" is not hoisted
x = 23;

Note - To avoid hoisting, you can run javascript in strict mode by using “use strict” on top of the code:

"use strict";
x = 23; // Gives an error since 'x' is not declared
var x; 

Temperal Dead zone - 

Temperal Dead zone work with let and const because we can access before intializations or decleations

ex - 

console.log(x);
let x= 3;
ReferenceError: Cannot access 'x' before initialization



Difference between “ == “ and “ === “ operators.

Both are comparison operators. The difference between both the operators is that “==” is used to compare values
 whereas, “ === “ is used to compare both values and types.

Ex -

var x = 2;
var y = "2";
(x == y)  // Returns true since the value of both x and y is the same
(x === y) // Returns false since the typeof x is "number" and typeof y is "string"

Explain closers 

closure gives a access to an outer function's scope from an inner function 

Ex - 1

function makeFunc() {
  const name = "Mozilla";
  function displayName() {
	
    console.log(name);
  }
  return displayName;
}

const myFunc = makeFunc();
myFunc();



Expain Destructuing 

The destructuring assignment is an expression that makes it easy to extract values from arrays, or properties from objects, into distinct variables.

There are two types of destructuring assignment expressions, namely, Array Destructuring and Object Destructuring. It can be used in the following manner :

Object Destructuring 
ex-

 1 .const employee1 = {
    name :"chandu",
    age :'26',
    address :{
        city :"samastipur",
        state :'bihar'
    }
}
const  {name,age} = employee1
console.log(name)

2. const employee1 = {
    name :"chandu",
    age :'26',
    address :{
        city :"samastipur",
        state :'bihar'
    }
}
const  {address : {city}} = employee1
console.log(city)

3. const employee = {
    name :"chandu",
    age :'26',
    address :{
        city :"samastipur",
        state :'bihar'
    }
}
function fun1(age,name){
    console.log(`Employee name ${employee.name}`)
}
fun1(employee);

Array Desctring

ex -1 

const fruit = ["apple","bananan","pineapple"]

const [fruit1,fruit2] = fruit
console.log(fruit1)

Explain ES6 features 

1.let and const Keywords
2.Rest operater
3.Spread operater
4.Async/Await 
5.Destructing
6.Arrow Functions 
7.Multi-line Strings
8.Default Parameters
9.Template Literals
10.Destructuring Assignment
11.Enhanced Object Literals
12.Promises
13.Classes
14.Modules

Expain map,reducer,filter 

map() - map method is used for creating a new array from an existing one
 map fucntion work with callback function it takes 3 arguments
ex- 
const arr1 = [2,5,7,8,9]
const arr2 = arr1.map((element)=>{
   return element*2;
})
console.log(arr2)

filter () - filter method work with conditions 
 it is also created a new array from an existing array
Ex -
const arr1 = [2,5,7,8,9]
const arr2 = arr1.filter((element)=>{
   return element%2===0;
})
console.log(arr2)

reduce() - reduce method work with 2 paramter i.e previous & cnt it is produces single value


ex- 

const arr1 = [2,5,7,8,9]
const arr2 = arr1.reduce((prev,curr)=>{
  return prev+curr;
})
console.log(arr2) //o/p - 31

Expain Spread & Rest operaor

spread operaotr  - The JavaScript spread operator (...) allows us to quickly copy all or part of an existing array or object into another array or object.

Ex- 1

 var array1 = [10, 20, 30, 40, 50];
    var array2 = [60, 70, 80, 90, 100];
    var array3 = [...array1, ...array2];
   console.log(array3);

ex-2

 var array1 = [10, 20, 30, 40, 50];
    var array2 = [...array1, 60];
    console.log(array2);

Rest parameter - The Rest operater is usd to put the rest of some specific user supplied values into a javascript array
Note: There must be only one rest operator in javascript functions.

Syntax:

function function_name(...arguments) {
    statements;
}
ex 

function fruits(a, ...z){
     console.log("fruits",z)
    
}
fruits("apple","bananana","orange")
o/p = 

fruits [ 'bananana', 'orange' ]

Expain array & its method 

1.toString - The JavaScript method toString() converts an array to a string of (comma separated) array values.
ex - let arr = ["chandra","anita","komal","ranjan"]

     let arr2 = arr.toString()
     console.log(arr2) o/p - chandra,anita,komal,ranjan
2.join () - The join() method also joins all array elements into a string.

          It behaves just like toString(), but in addition you can specify the separator:

         ex - let arr = ["chandra","anita","komal","ranjan"]


        let arr2 = arr.join(" and ")
        console.log(arr2) o/p -chandra and anita and komal and ranjan

3. concat() - The concat() method creates a new array by merging (concatenating) existing arrays:

ex-

let arr = ["chandra","anita","komal","ranjan"]
let arr1 = ["priya","priti","piyhu","pink"]


let arr2 = arr.concat(arr1)
console.log(arr2)

0/p -[
  'chandra', 'anita',
  'komal',   'ranjan',
  'priya',   'priti',
  'piyhu',   'pink'
]

4. pop() - The pop() method removes the last element from an array:

const fruits = ["Banana", "Orange", "Apple", "Mango"];

const fruit2 = fruits.pop();

console.log(fruits2) // Banana,Orange,Apple

5. push () - The push() method adds a new element to an array (at the end):

Ex -

const fruits = ["Banana", "Orange", "Apple"];

const fruit2 = fruits.push("Mango");

console.log(fruits2) // Banana,Orange,Apple,Mango

6. shift() - The shift() method removes the first array element and "shifts" all other elements to a lower index.

7. unshift() - The unshift() method adds a new element to an array (at the beginning), and "unshifts" older elements:

8. Splice () - The splice() method in JavaScript is used to modify an array by adding or removing elements at a specified index
		It can be used to add elements, remove elements, or both, in a single operation.
		The splice() method modifies the original array and returns an array containing the removed elements

syntax - array.splice(startIndex, deleteCount, item1, item2, ...)

startIndex: The index at which to start modifying the array.
deleteCount: The number of elements to remove from the array starting at the startIndex.
item1, item2, ...: Optional items to add to the array at the startIndex.

ex-1 

let numbers = [1, 2, 3, 4, 5];
let removed = numbers.splice(1, 2); // Removes 2 elements starting from index 1
// numbers is now [1, 4, 5]
// removed is [2, 3]

ex-2 

let fruits = ['apple', 'banana', 'cherry'];
fruits.splice(1, 0, 'orange', 'grape'); // Inserts 'orange' and 'grape' at index 1
// fruits is now ['apple', 'orange', 'grape', 'banana', 'cherry']

9.slice(): The slice() method in JavaScript is used to create a shallow copy of a portion of an array. 
It doesn't modify the original array but returns a new array containing elements from the specified starting index to the specified ending index (excluding the ending index itself). 
The original array remains unchanged.

syntx - array.slice(startIndex, endIndex);

startIndex: The index at which to begin extracting elements. If negative, it counts from the end of the array.
endIndex (optional): The index at which to stop extracting elements. The slice() method goes up to, but does not include, 
the element at this index. If omitted, the slice includes all elements from startIndex to the end of the array.

ex- 

const fruits = ['apple', 'banana', 'cherry', 'date', 'elderberry'];
const slicedFruits = fruits.slice(1, 4); // Creates a new array with elements at indexes 1, 2, and 3
// slicedFruits is ['banana', 'cherry', 'date']

The slice() method is commonly used when you want to work with a specific portion of an array without altering the original array.

10.indexOf() - it is uesd to find the index number of element

ex- 

const fruits = ['apple', 'banana', 'cherry', 'date'];

const index = fruits.indexOf('cherry'); // Returns 2
const notFoundIndex = fruits.indexOf('grape'); // Returns -1

11.lastIndexOf() - it is use to find left ot right of array 

es - 

const fruits = ['apple', 'banana', 'cherry', 'date', 'banana'];

const index = fruits.lastIndexOf('banana'); // Returns 4 (index of the last occurrence)
const notFoundIndex = fruits.lastIndexOf('grape'); // Returns -1

12. flat() - The flat() method in JavaScript is used to create a new array that's a one-dimensional flat version of a given array

syntax- array.flat([depth]);

ex- 

const nestedArray = [1, [2, [3, 4]]];
const flatArray = nestedArray.flat(); // Flattens to [1, 2, [3, 4]]

const deeplyNestedArray = [1, [2, [3, [4]]]];
const deeplyFlatArray = deeplyNestedArray.flat(Infinity); // Flattens to [1, 2, 3, 4]

13. lengh () - it is uesd to find the lenght of array

14 forEach() - The forEach() method in JavaScript is used to iterate over the elements of an array and execute a provided callback function once for each element.
syntax - 

array.forEach(callback(currentValue, index, array), thisArg);

ex - 

const numbers = [1, 2, 3, 4, 5];

numbers.forEach((number, index) => {
  console.log(`Element at index ${index} is ${number}`);
});

14.find() - This method is use to find the first matched of array element 

15. findIndex() - This method is uesd to find first matched of array index

16.Sort() - This method is ues to sort the array element by alphabetcally

ex - let nums = [1,2,5,3,4]
 let sortedarray = nums.sort();
console.log(sortedarray) o/p - [ 1, 2, 3, 4, 5 ]

let num = [1,2,11,5,4,]

let sorted = num.sort((a,b)=>a-b)
console.log(sorted) o/p -[ 1, 2, 4, 5, 11 ]

17.some() - 

18.every() - 

19.includes() - 
20.fill() - 
21.copyWithIn()-
22.reverse() -
23.form () - 
24isArray() - 
25.valueOf() - 
26.entries() - 
27.key() - 
28values()-
29.reduceRight()-
30.flatMap()-

what is prototype chain 
https://www.scaler.com/topics/javascript/prototype-inheritance-in-javascript
https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object_prototypes


Prototype chaining is used to build new types of objects based on existing ones. It is similar to inheritance in a class based language.

or 


Prototype inheritance in JavaScript is a mechanism by which objects in JavaScript can inherit properties and methods from other objects. 
Every object in JavaScript has an internal property called [[Prototype]] (often referred to as the prototype), which points to another object.
When you access a property or method on an object, JavaScript first looks for that property or method on the object itself. 
If it doesn't find it, it looks at the object's prototype, and then the prototype's prototype, and so on until it finds the property or method or reaches the end of the prototype chain.

ex - 1

// Define a parent object
const animal = {
  type: 'unknown',
  sound() {
    console.log('Animal sound');
  }
};

// Create a child object that inherits from the parent object
const dog = Object.create(animal);
dog.type = 'dog';
dog.bark = function() {
  console.log('Woof!');
};

// Accessing properties and methods
console.log(dog.type); // Output: dog
dog.sound(); // Output: Animal sound
dog.bark(); // Output: Woof!

ex-2
// Define a constructor function
function Person(name, age) {
  this.name = name;
  this.age = age;
}

// Add a method to the Person prototype
Person.prototype.sayHello = function() {
  console.log(`Hello, my name is ${this.name} and I am ${this.age} years old.`);
};

// Create an object using the Person constructor
let person1 = new Person('Alice', 30);

// Call the sayHello method
person1.sayHello(); // Output: Hello, my name is Alice and I am 30 years old.

// Create another object using the Person constructor
let person2 = new Person('Bob', 25);

// Call the sayHello method on the second object
person2.sayHello(); // Output: Hello, my name is Bob and I am 25 years old.



What are object prototypes? 

Prototype Chain: 
Each object in JavaScript has a prototype, except for the base object Object.prototype, which is the final link in the prototype chain. 
When you try to access a property or method on an object, JavaScript first looks for it on the object itself. 
If it doesn't find it, it continues up the prototype chain until it finds the property or method or reaches the end of the chain.

Prototypal Inheritance: 
JavaScript uses prototypal inheritance, meaning objects inherit properties and methods from their prototype. This allows for code reuse and the creation of object hierarchies.

Constructor Functions and Prototypes: 
Constructor functions in JavaScript are typically used to create objects that share a common prototype. 
When you create an object using a constructor function with the new keyword, the object's prototype is set to the constructor function's prototype.

Modifying Prototypes: 
You can add properties and methods to an object's prototype dynamically. Any object that inherits from that prototype will automatically have access to those properties and methods.
Object.create(): The Object.create() method allows you to create a new object with a specified prototype. This method is often used to create objects with custom prototypes.


Ex- 
1.
// constructor function
function Person () {
    this.name = 'John',
    this.age = 23
}

// creating objects
const person1 = new Person();
const person2 = new Person();

// adding property to constructor function
Person.prototype.gender = 'male';

// prototype value of Person
console.log(Person.prototype);

// inheriting the property from prototype
console.log(person1.gender);
console.log(person2.gender);

what is cookies

A cookie is generally a small data that is sent from a website and stored on the user’s machine by a web browser that was used to access the website. 
Cookies are used to remember information for later use and also to record the browsing activity on a website.

A cookie is a piece of data that is stored on our computer to be accessed by  browser.
Cookies are saved as key/value pairs. For exammple

The simplest way of creating a cookie using JavaScript is as below:

document.cookie = "key1 = value1; key2 = value2; expires = date";

How would you read a cookie? 

Reading a cookie using JavaScript is also very simple. 
We can use the document.cookie string that contains the cookies that we just created using that string.

The document.cookie string keeps a list of name-value pairs separated by semicolons, where ‘name’ is the name of the cookie, and ‘value’ is its value.
 We can also use the split() method to break the cookie value into keys and values.

 
How would you delete a cookie?

To delete a cookie, we can just set an expiration date and time. 
Specifying the correct path of the cookie that we want to delete is a good practice since some browsers won’t allow the deletion of cookies unless there is a clear path that tells which cookie to delete from the user’s machine.

function delete_cookie(name) {

  document.cookie = name + "=; Path=/; Expires=Thu, 01 Jan 1970 00:00:01 GMT;";

}



JavaScript Event Handlers

Event handlers can be used to handle and verify user input, user actions, and browser actions:

Things that should be done every time a page loads
Things that should be done when the page is closed
Action that should be performed when a user clicks a button
Content that should be verified when a user inputs data

Explain Promises

Promises in JavaScript are a way to handle asynchronous operations in a more organized and structured manner

There are 3 states

Pending: The initial state when a Promise is created. It represents that the operation is in progress, and the result is not available yet.

Fulfilled (Resolved): The state when the asynchronous operation is completed successfully. The Promise transitions to this state, and we can access the result using .then().

Rejected: The state when the asynchronous operation encounters an error. The Promise transitions to this state, and we can handle the error using .catch().
 syntax - 

// Example function that returns a promise
function fetchData() {
    return new Promise((resolve, reject) => {
        // Simulating an asynchronous operation with setTimeout
        setTimeout(() => {
            const success = true; // Set to false for demonstration of rejection
            if (success) {
                resolve("Data fetched successfully!");
            } else {
                reject("Error fetching data!");
            }
        }, 2000);
    });
}

// Using the promise
fetchData()
    .then((result) => {
        console.log(result); // Output: Data fetched successfully!
    })
    .catch((error) => {
        console.error(error); // Output: Error fetching data!
    })
    .finally(() => {
        console.log("Promise settled.");
    });


promises.all =Promise.all is a method in JavaScript that takes an array of promises and returns a single promise. 
This new promise is fulfilled with an array of resolved values from the input promises,
in the same order as the promises passed to Promise.all

ex 

// Simulated asynchronous functions returning Promises
function asyncFunction1() {
    return new Promise(resolve => {
        setTimeout(() => {
            console.log("Async Function 1");
            resolve("Result from Function 1");
        }, 1000);
    });
}

function asyncFunction2() {
    return new Promise(resolve => {
        setTimeout(() => {
            console.log("Async Function 2");
            resolve("Result from Function 2");
        }, 1000);
    });
}

function asyncFunction3() {
    return new Promise(resolve => {
        setTimeout(() => {
            console.log("Async Function 3");
            resolve("Result from Function 3");
        }, 1000);
    });
}

// Using Promise.all with an array of promises
const promisesArray = [asyncFunction1(), asyncFunction2(), asyncFunction3()];

Promise.all(promisesArray)
    .then(results => {
        console.log("All promises resolved:", results);
    })
    .catch(error => {
        console.error("One of the promises was rejected:", error);
    });

Promises chain =

A promise chain is a series of asynchronous operations where each operation returns a promise, 
allowing you to chain multiple asynchronous calls together in a more readable and sequential manner. 
The key feature that enables promise chaining is the fact that a promise's .then() method returns a new promise, 
which can be further chained.

ex -

function asyncFunction1() {
    return new Promise((resolve) => {
        setTimeout(() => {
            console.log("Async Function 1");
            resolve("Result from Function 1");
        }, 1000);
    });
}

function asyncFunction2(data) {
    return new Promise((resolve) => {
        setTimeout(() => {
            console.log("Async Function 2");
            resolve(`Result from Function 2 using ${data}`);
        }, 1000);
    });
}

function asyncFunction3(data) {
    return new Promise((resolve) => {
        setTimeout(() => {
            console.log("Async Function 3");
            resolve(`Result from Function 3 using ${data}`);
        }, 1000);
    });
}

// Using promise chaining
asyncFunction1()
    .then((result1) => asyncFunction2(result1))
    .then((result2) => asyncFunction3(result2))
    .then((finalResult) => {
        console.log("Final result:", finalResult);
    })
    .catch((error) => {
        console.error("Error in the promise chain:", error);
    });

We can handle promise settlement using the .then() and .catch() methods on a promise 

if we were to imagine a Promise.settle method, it could potentially settle an array of promises, meaning 
it would wait for all promises in the array to either fulfill or reject, and then return an array of objects representing the outcome of each promise.
Each object in the resulting array might contain information about whether the promise was fulfilled or rejected, and the value or reason for the fulfillment or rejection.

Promise.settle = function(promises) {
  return Promise.all(promises.map(promise =>
    Promise.resolve(promise)
      .then(value => ({ status: 'fulfilled', value }))
      .catch(reason => ({ status: 'rejected', reason }))
  ));
};


Explain types of functions 
There are several types of functions, each serving different purposes. Here are some common types of functions with examples:
1.Named Functions 

Named functions are defined using the function keyword followed by the function name.
They can be accessed from anywhere within their scope.

Ex :
function greet(name) {
  console.log(`Hello, ${name}!`);
}

greet('Alice'); // Output: Hello, Alice!

2.Function Expressions:
Function expressions define functions as values assigned to variables.
They can be anonymous (without a name) or named.

// Anonymous function expression
const greet = function(name) {
  console.log(`Hello, ${name}!`);
};

greet('Bob'); // Output: Hello, Bob!

// Named function expression
const sayHello = function greet(name) {
  console.log(`Hello, ${name}!`);
};

sayHello('Charlie'); // Output: Hello, Charlie!

3.Arrow Functions: 
Arrow functions provide a more concise syntax compared to traditional function expressions.
They don't have their own this, arguments, super, or new.target, making them suitable for non-method functions.

const square = (x) => x * x;

console.log(square(5)); // Output: 25

4.Immediately Invoked Function Expressions (IIFE):

IIFE is a function expression that is executed immediately after it's defined.
They are often used to create a new scope and avoid polluting the global namespace.

(function() {
  const message = 'Hello from IIFE!';
  console.log(message);
})();

// Output: Hello from IIFE!
5.Higher-Order Functions:
Higher-order functions are functions that either take other functions as arguments or return functions.
They enable functional programming paradigms like map, filter, reduce, etc.

const numbers = [1, 2, 3, 4, 5];

const squaredNumbers = numbers.map((num) => num * num);

console.log(squaredNumbers); // Output: [1, 4, 9, 16, 25]

function operate(operator, a, b) {
    return operator(a, b);
}

function add(a, b) {
    return a + b;
}

function subtract(a, b) {
    return a - b;
}

console.log(operate(add, 5, 3)); // Output: 8
console.log(operate(subtract, 5, 3)); // Output: 2




6.Generator Functions:
Generator functions allow you to define an iterator.
They use the function* syntax and yield keyword to pause and resume execution.

function* generator() {
  yield 1;
  yield 2;
  yield 3;
}

const iterator = generator();

console.log(iterator.next().value); // Output: 1
console.log(iterator.next().value); // Output: 2
console.log(iterator.next().value); // Output: 3

Explain annonamusion function

Anonynous function is a arrow function  or nameless function, fat arrow function

synatx - ()=>{statements}



Expain async & await

async and await are keywords in JavaScript used to work with asynchronous code in a more synchronous and readable manner.

async Function:

You declare a function as async by placing the async keyword before the function keyword in its definition.

An async function always returns a Promise implicitly. 

This Promise will be fulfilled with the value that the function returns or rejected with an error thrown from within the function.
Inside an async function, We can use the await keyword to pause the execution until a Promise is settled (fulfilled or rejected). 

This allows you to write asynchronous code that looks more like synchronous code.

syntax - 

// Example function that returns a Promise after a delay
function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

// Asynchronous function using async and await
async function exampleAsyncFunction() {
  console.log('Start');

  // Using await to pause execution until the Promise is resolved
  await delay(2000); // This simulates a time-consuming operation (e.g., API call)

  console.log('After 2 seconds');
  
  // Another asynchronous operation
  await delay(1000);

  console.log('After another second');

  // Returning a value as if it were a synchronous function
  return 'Done';
}

// Using the asynchronous function
async function runExample() {
  try {
    const result = await exampleAsyncFunction();
    console.log(result);
  } catch (error) {
    console.error('An error occurred:', error);
  }
}

// Calling the function that uses async/await
runExample();


await Expression:

The await keyword is used to indicate that a Promise should be awaited inside an async function.

When you use await, it suspends the execution of the async function until the awaited Promise is settled.

You can use await with any function that returns a Promise, including native browser APIs (e.g., fetch), custom functions returning Promises, or other async functions.

async function example() {
  const result = await someAsyncFunction();
  console.log(result); // The result of someAsyncFunction()
}


Error Handling:

We can handle errors in async functions using try...catch. If an awaited Promise is rejected, the control will jump to the nearest catch block.

async function fetchData() {
  try {
    const data = await fetchSomeData();
    return data;
  } catch (error) {
    console.error(error); // Handle the error
    throw error; // Rethrow the error if needed
  }
}

async Arrow Functions:

const fetchData = async () => {
  // Asynchronous code here
};

You can also use async with arrow functions.

Promise.all() with async and await:

To execute multiple asynchronous operations in parallel, you can use Promise.all() along with await.

async function fetchAllData() {
  const [data1, data2] = await Promise.all([fetchData1(), fetchData2()]);
  return [data1, data2];
}

async and await simplify the handling of asynchronous code, making it more readable and maintainable. 
They have become the preferred way to work with Promises in modern JavaScript development.



Explain shallCopy & Deep Copy

Shallow Copy - 

Shallow Copy stores the references of objects to the original memory address.
Shallow Copy reflects changes made to the new  object in the original object
A shallow copy is faster.

Deep Copy - 
 Deep copy stores copies of the object's value
 Deep copy doesn't reflect changes made to the new/copied object in the original object
 Deep copy is comparatively slower.


Explain Events loop
https://www.geeksforgeeks.org/what-is-an-event-loop-in-javascript/

Things that should be done every time a page loads
Things that should be done when the page is closed
Action that should be performed when a user clicks a button
Content that should be verified when a user inputs data

Ex - onClick,onmouseover,onBlur,onLoad
a. Event propagation 
b.stop propagation

Explain firstClass functions

A programming language is said to have First-class functions if functions in that language are treated like other variables. 
So the functions can be assigned to any other variable or passed as an argument or can be returned by another function.

1.Assigned to variables: You can assign a function to a variable just like you would any other value.

2.Passed as arguments: Functions can be passed as arguments to other functions.

3.Returned from other functions: Functions can be returned as values from other functions.

4.Stored in data structures: Functions can be stored in arrays, objects, or any other data structure.

Ex - 

// Function assigned to a variable
const greet = function(name) {
  return `Hello, ${name}!`;
};

// Function passed as an argument
function sayHello(greetingFunction, name) {
  return greetingFunction(name);
}

console.log(sayHello(greet, 'Alice')); // Output: Hello, Alice!

// Function returned from another function
function createGreeter(greeting) {
  return function(name) {
    return `${greeting}, ${name}!`;
  };
}

const greetWithHi = createGreeter('Hi');
console.log(greetWithHi('Bob')); // Output: Hi, Bob!



Expain  Event capturing & event bubbling 

https://www.javatpoint.com/event-bubbling-and-capturing-in-javascript

1.Event Bubbling
While developing a webpage or a website via JavaScript, 
the concept of event bubbling is used where the event handlers are invoked when one element is nested on to the other element and are part of the same event. 
This technique or method is known as Event Bubbling. Thus, while performing event flow for a web page, 
event bubbling is used. We can understand event bubbling as a sequence of calling the event handlers when one element is nested in another element, 
and both the elements have registered listeners for the same event. So beginning from the deepest element to its parents covering all its ancestors on the way to top to bottom, 
calling is performed.

ex 
 
<div id="outer">
    <div id="inner">Click me!</div>
</div>
document.getElementById('outer').addEventListener('click', function() {
    console.log('Outer div clicked');
});

document.getElementById('inner').addEventListener('click', function() {
    console.log('Inner div clicked');
});

explanation

If you click on the "inner" div, both event handlers will be triggered, first the one attached to the "inner" div, then the one attached to the "outer" div.

Event Capturing
Netscape Browser was the first to introduce the concept of Event Capturing. Event Capturing is opposite to event bubbling, 
where in event capturing, an event moves from the outermost element to the target. Otherwise, in case of event bubbling, 
the event movement begins from the target to the outermost element in the file. 
Event Capturing is performed before event bubbling but capturing is used very rarely because event bubbling is sufficient to handle the event flow.

Ex 

<div id="outer">
    <div id="inner">Click me!</div>
</div>

document.getElementById('outer').addEventListener('click', function() {
    console.log('Outer div clicked');
}, true); // The third parameter 'true' indicates capturing phase

document.getElementById('inner').addEventListener('click', function() {
    console.log('Inner div clicked');
}, true);

Explanaton

In this case, clicking on the "inner" div will first trigger the event handler attached to the "outer" div (during the capturing phase), and then the one attached to the "inner" div 
(during the bubbling phase).

By default, event handlers are registered for the bubbling phase. However, you can specify the capturing phase by passing true as the third parameter to addEventListener.


what is Temperal dead zone 

https://www.educative.io/answers/what-is-the-temporal-dead-zone-in-javascript

Expain higher order function

Higher-order functions are the functions that take functions as arguments and return them by operating on other functions

Explain Debounching in javascript

Debouncing is a programming technique that assures that time-consuming activities do not trigger the web page's performance decreases. 
In other words, the Debounce methods do not run when invoked. Instead, they wait a predetermined period of time until executing.
When we call the same process again, the previous process is canceled, and the timer is reset.
Debouncing is a method used in JavaScript to increase browser performance. There may be some features on a web page that needs time-consuming computations
Ex- 
const debounce = (func, wait) => {  
  let timeout;  
  return function mainFunction(...args) {  
    const later = () => {  
      clearTimeout(timeout);  
      func(...args);  
    };  
    clearTimeout(timeout);  
    timeout = setTimeout(delay, wait);  
  };  
};  

Explain Thorthling

https://medium.com/codex/throttling-in-javascript-649375f6b9f#:~:text=As%20mentioned%20in%20the%20beginning,a%20system%20or%20degrading%20performance.
https://www.geeksforgeeks.org/javascript-throttling/

Throttling in JavaScript is a technique used to limit the number of times a function is called over a specified time period. 
It's particularly useful for performance optimization, preventing resource-intensive operations from overwhelming the browser or server with too many requests or computations in a short time frame.

Throttling ensures that a function is executed at most once during a specified interval, even if it's called multiple times within that interval. 
This helps to smooth out spikes in function calls and prevents unnecessary processing or rendering.

Ex 

function throttle(func, delay) {
  let timeoutId;
  let lastExecutedTime = 0;

  return function(...args) {
    const currentTime = Date.now();

    if (currentTime - lastExecutedTime >= delay) {
      func.apply(this, args);
      lastExecutedTime = currentTime;
    } else {
      if (!timeoutId) {
        timeoutId = setTimeout(() => {
          func.apply(this, args);
          lastExecutedTime = Date.now();
          timeoutId = null;
        }, delay - (currentTime - lastExecutedTime));
      }
    }
  };
}



Self Invoking Functions

Self Invoking Functions is an automatically invoked function expression followed by (), 
where it does not need to be requested. Nevertheless, the declaration of the function is not able to be invoked by itself. 

currying in JavaScript (with examples)

In JavaScript, when a function of an argument is transformed into functions of one or more arguments is called Currying.

Example:

function add (a) {

  return function(b){

    return a + b;

  }

}

add(3)(4) 

Types of errors in javascript
Javascript has two types of errors, Syntax error, and Logical error.

What is memoization?
In JavaScript, when we want to cache the return value of a function concerning its parameters, it is called memoization. 
It is used to speed up the application especially in case of complex, time consuming functions. 

What is BOM?
BOM is the Browser Object Model where users can interact with browsers that is a window, an initial object of the browser. 
The window object consists of a document, history, screen, navigator, location, and other attributes. 
Nevertheless, the window’s function can be called directly as well as by referencing the window.

What are generator functions?
Generator functions are declared with a special class of functions and keywords using function*. 
It does not execute the code, however, it returns a generator object and handles the execution.

Explain Pure functions

https://www.freecodecamp.org/news/what-is-a-pure-function-in-javascript-acb887375dfe/
https://www.geeksforgeeks.org/pure-functions-in-javascript
https://www.scaler.com/topics/pure-function-in-javascript/

Explain first class function

https://developer.mozilla.org/en-US/docs/Glossary/First-class_Function

Explain promisis all 

https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all

Explain ES6 features

https://www.divami.com/blog/top-ecmascript-es6-features-every-javascript-developer-should-know

https://www.boardinfinity.com/blog/top-10-features-of-es6/

https://github.com/lukehoban/es6features

Explain Memorization 

https://www.freecodecamp.org/news/memoization-in-javascript-and-react/#:~:text=With%20memoization%2C%20there's%20no%20need,same%20value%20when%20required%20again.
https://www.syncfusion.com/blogs/post/what-is-memoization-in-react.aspx



Explain CallBack  and callBack hell

Call Back = A callback function is a function passed into another function as an argument, which is then invoked inside the outer function to complete some kind of routine or action.


ex 1 

// Function that takes a callback

function doSomethingAsync(callback) {
    setTimeout(function () {
        console.log("Task done!");
        callback();
    }, 1000);
}

// Callback function
function afterTask() {
    console.log("Callback executed!");
}

// Calling the function with the callback

doSomethingAsync(afterTask);

ex -2 

// Function that takes a callback with parameters
function calculate(a, b, callback) {
    const result = a + b;
    callback(result);
}

// Callback function with parameter
function displayResult(result) {
    console.log("The result is:", result);
}

// Calling the function with the callback
calculate(5, 10, displayResult);

ex-3 

// Promise that resolves after a delay
const myPromise = new Promise(function (resolve) {
    setTimeout(function () {
        resolve("Promise resolved!");
    }, 2000);
});

// Using then() with a callback
myPromise.then(function (result) {
    console.log(result);
});

callBack hell = nested callback stacked


// Example of callback hell
asyncFunction1((error, result1) => {
    if (error) {
        console.error(error);
    } else {
        asyncFunction2(result1, (error, result2) => {
            if (error) {
                console.error(error);
            } else {
                asyncFunction3(result2, (error, result3) => {
                    if (error) {
                        console.error(error);
                    } else {
                        // ... and it goes on
                    }
                });
            }
        });
    }
});

// Simulated asynchronous functions
function asyncFunction1(callback) {
    setTimeout(() => {
        console.log("Async Function 1");
        callback(null, "Result from Function 1");
    }, 1000);
}

function asyncFunction2(data, callback) {
    setTimeout(() => {
        console.log("Async Function 2");
        callback(null, "Result from Function 2");
    }, 1000);
}

function asyncFunction3(data, callback) {
    setTimeout(() => {
        console.log("Async Function 3");
        callback(null, "Result from Function 3");
    }, 1000);
}

ex-2

// Example using Promises
asyncFunction1()
    .then(result1 => asyncFunction2(result1))
    .then(result2 => asyncFunction3(result2))
    .then(result3 => {
        console.log("Final result:", result3);
    })
    .catch(error => {
        console.error(error);
    });

// Simulated asynchronous functions returning Promises
function asyncFunction1() {
    return new Promise(resolve => {
        setTimeout(() => {
            console.log("Async Function 1");
            resolve("Result from Function 1");
        }, 1000);
    });
}

function asyncFunction2(data) {
    return new Promise(resolve => {
        setTimeout(() => {
            console.log("Async Function 2");
            resolve("Result from Function 2");
        }, 1000);
    });
}

function asyncFunction3(data) {
    return new Promise(resolve => {
        setTimeout(() => {
            console.log("Async Function 3");
            resolve("Result from Function 3");
        }, 1000);
    });
}

https://medium.com/@avinashkumar151199/what-is-callback-hell-a4594574e3c7
https://www.geeksforgeeks.org/what-to-understand-callback-and-callback-hell-in-javascript/
https://www.simplilearn.com/tutorials/javascript-tutorial/callback-function-in-javascript#:~:text=A%20JavaScript%20callback%20is%20a,called%20as%20a%20callback%20function.

Implicit Type Coercion in javascript (in detail with examples)

When the value of one data type is automatically converted into another data type, it is called Implicit type coercion in javascript.

Example: 

var x = 4;

var y = "4";

x + y // Returns "44"




Explain math
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math

Explain numbers

https://www.javatpoint.com/javascript-number
https://www.programiz.com/javascript/array

Explain timer function & its method 

https://www.w3schools.com/js/js_timing.asp

Explian cookies 
https://www.geeksforgeeks.org/es6-cookies/
https://www.javascripttutorial.net/web-apis/javascript-cookies/

Explain LocalStorgae

https://www.freecodecamp.org/news/web-storage-localstorage-vs-sessionstorage-in-javascript/

what is currying  

https://builtin.com/software-engineering-perspectives/currying-javascript
https://www.geeksforgeeks.org/what-is-currying-function-in-javascript/
https://blog.logrocket.com/understanding-javascript-currying/

Expain Global variable V/s local varible

https://www.javatpoint.com/local-variable-vs-global-variable

Explain function expression

https://www.geeksforgeeks.org/javascript-function-expression/

explain objects 

https://www.javatpoint.com/javascript-objects

Explain timer function & its method 

https://www.javatpoint.com/javascript-timer
https://www.tutorialrepublic.com/javascript-tutorial/javascript-timers.php


How do you handle asynchronous operations in JavaScript? Briefly explain the concepts of callbacks, Promises, and async/await.

https://medium.com/@ghostsmaw/asynchronous-javascript-understanding-callbacks-promises-and-async-await-660e6f606d48#:~:
text=Callbacks%2C%20promises%2C%20and%20the%20async,user%20interface%20and%20other%20operations.

How would you check the data type of a variable in JavaScript? 

https://www.freecodecamp.org/news/javascript-data-types-typeof-explained/#:~:text=typeof%20is%20a%20JavaScript%20keyword,a%20variable%20in%20your%20code.

How do you create and use functions in JavaScript?

https://www.javatpoint.com/how-to-write-a-function-in-javascript

What is the purpose of the this keyword in JavaScript? How does it behave in different contexts?

https://www.simplilearn.com/tutorials/javascript-tutorial/javascript-this-keyword#
:~:text=%E2%80%9CThis%E2%80%9D%20keyword%20refers%20to%20an,this%E2%80%9D%20references%20the%20global%20object.

What are arrow functions, and how do they differ from regular functions?

https://www.geeksforgeeks.org/difference-between-regular-functions-and-arrow-functions/

How do you handle errors in JavaScript? Explain the try...catch statement.

https://www.javatpoint.com/javascript-try-catch

What are modules in JavaScript? How do they help in optimizing code?

https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules

https://developer.mozilla.org/en-US/docs/Learn/Performance/JavaScript

What are the different ways to create objects in JavaScript, and what is the difference between them?

https://www.geeksforgeeks.org/creating-objects-in-javascript-4-different-ways/

Explain for & forEach

https://www.geeksforgeeks.org/difference-between-foreach-and-for-loop-in-javascript/
https://javascript.plainenglish.io/javascript-for-loops-vs-for-each-the-difference-explained-39a1378f14d7




Explain the difference between function declarations and function expressions in JavaScript.
What is the purpose of the this keyword in JavaScript? How does it behave in different contexts?

Explain the concept of prototypal inheritance in JavaScript.

What are the different ways to create objects in JavaScript?

What are arrow functions in JavaScript? How do they differ from regular functions?

Arrow functions are a shorthand syntax for writing function expressions in JavaScript. 
They provide a more concise and sometimes clearer way to define functions, 

function add(a, b) {
  return a + b;
}
function add(a, b) {
  return a + b;
}

const add = (a, b) => a + b;

Lexical this binding:

Arrow functions do not have their own this context. Instead, they lexically bind this from their surrounding scope.
In regular functions, this is dynamically scoped and can change based on how the function is called.
This difference is especially significant when working with object methods or event handlers.

No arguments object:

Arrow functions do not have their own arguments object. Instead, they inherit arguments from their parent scope.
Regular functions have their own arguments object, which is an array-like object containing all the arguments passed to the function.

Cannot be used as constructors:

Arrow functions cannot be used as constructors with the new keyword. Attempting to do so will result in a runtime error.
Regular functions can be used as constructors to create new instances of objects.

const obj = {
  name: 'John',
  regularFunc: function() {
    console.log('Regular function:', this.name);
  },
  arrowFunc: () => {
    console.log('Arrow function:', this.name);
  }
};

obj.regularFunc(); // Outputs: Regular function: John
obj.arrowFunc();   // Outputs: Arrow function: undefined (this refers to the global object)

const boundRegularFunc = obj.regularFunc.bind({ name: 'Jane' });
boundRegularFunc(); // Outputs: Regular function: Jane (bind creates a new this context)

const boundArrowFunc = obj.arrowFunc.bind({ name: 'Jane' });
boundArrowFunc();   // Outputs: Arrow function: undefined (arrow functions cannot be rebound)


What are the different ways to iterate over objects and arrays in JavaScript?

Explain the concept of scope in JavaScript. How does it affect variable accessibility?

Explain the concept of scope and lexical scope in JavaScript.

Find the duplicates array in a using javascript

const myArray = [1, 2, 3, 2, 4, 5, 5,4, 6];

function findDuplicates(array) {
  return array.filter((item, index) => array.indexOf(item) !== index);
}


const duplicates = findDuplicates(myArray);

console.log("Duplicate values: ", duplicates); // Output: [2, 4,5]

Programes

1. find the sum of const obj = {'A': 8,'B': 15,'C': 2,'D': 5,'E': 10}

const obj = {'A': 8, 'B': 15, 'C': 2, 'D': 5, 'E': 10};

function sumObjectValues(obj) {
  let sum = 0;
  for (let i in obj) {
    sum += obj[i];
  }
  return sum;
}

const result = sumObjectValues(obj);
console.log(result); // Output: 40

2.find the duplicate and uniques number const arr = [1,5,9,1,5,3,1]

const arr = [1, 5, 9, 1, 5, 3, 1];

function findDuplicates(arr) {
  const numOccurrences = {};
  const duplicates = [];

  arr.forEach((num) => {
    if (numOccurrences[num]) {
      if (!duplicates.includes(num)) {
        duplicates.push(num);
      }
    } else {
      numOccurrences[num] = 1;
    }
  });

  return duplicates;
}

const duplicateNumbers = findDuplicates(arr);
console.log("Duplicate Numbers:", duplicateNumbers); // Output: Duplicate Numbers: [1, 5]

3.Write a function fib() that takes an integer n and returns the series up to nth Fibonacci number.

function fib(n) {
  if (n <= 0) {
    return [];
  } else if (n === 1) {
    return [0];
  } else if (n === 2) {
    return [0, 1];
  } else {
    const series = [0, 1];
    for (let i = 2; i < n; i++) {
      series.push(series[i - 1] + series[i - 2]);
    }
    return series;
  }
}


const n = 6;
const fibonacciSeries = fib(n);
console.log(fibonacciSeries); 

4.Print the first “n” prime numbers. N is anything a user might enter.

function isPrime(number) {
  if (number <= 1) {
    return false;
  }
  if (number <= 3) {
    return true;
  }
  if (number % 2 === 0 || number % 3 === 0) {
    return false;
  }

  for (let i = 5; i * i <= number; i += 6) {
    if (number % i === 0 || number % (i + 2) === 0) {
      return false;
    }
  }

  return true;
}

function generatePrimes(n) {
  const primes = [];
  let number = 2;

  while (primes.length < n) {
    if (isPrime(number)) {
      primes.push(number);
    }
    number++;
  }

  return primes;
}

const n = parseInt(prompt("Enter the value of n:"));
const primeNumbers = generatePrimes(n);
console.log(`The first ${n} prime numbers are: ${primeNumbers.join(', ')}`);

function abc(){
    for (let i =0;i<5;i++)
    setTimeout(()=>{
       console.log(i) 
    },i*3000)
}
abc();
o/p - 0,1,2,3,4

function abc(){
    for (var i =0;i<5;i++)
    setTimeout(()=>{
       console.log(i) 
    },i*3000)
}
abc();
o/p - 5,5,5,5,5

5.Create an React component which will have a progress bar. It will increment after 1 secs. 
The progress bar will keep on incrementing till the width of the page is met and then it will stop incrementing.

4.Find the next palindrome number. If I pass any integer value to function it should return the next palindrome number.

var arr=[22,44,11,23,12,45,66,78];

let data=["cat","qwerty","qwtyre" ,"tac", "bat", "tab", "acc", "ac", "ca", "AAc","god","dog","AaAc","good","adog" ]
output =[
    [ 'cat', 'tac' ],
    [ 'qwerty', 'qwtyre' ],
    [ 'bat', 'tab' ],
    [ 'ac', 'ca' ],
    [ 'god', 'dog' ]
   ]

function findHighestNumber(){

print only key 

var person = { eyes: 2, feet: 2, hands: 2, eyeColor: "blue", active: true };

for (var key in person) {
  console.log(key);
}

var person = { eyes: 2, feet: 2, hands: 2, eyeColor: "blue", active: true };

var keys = Object.keys(person);

for (var i = 0; i < keys.length; i++) {
  console.log(keys[i]);
}
    
var person = { eyes: 2, feet: 2, hands: 2, eyeColor: "blue", active: true };

var values = Object.values(person);

for (var i = 0; i < values.length; i++) {
  console.log(values[i]);
}

let arr = [2, 4, 6, 8];

for (let i = 0; i < arr.length; i++) {
  arr[i] = arr[i] * 2;
}

console.log(arr); // Output: [4, 8, 12, 16]



console.log(duplicateElements);

Copy code
[1, 2, 3]

find the occurance 

const arr = [1, 2, 1, 3, 4, 2, 3];

function countOccurrences(arr) {
  const occurrenceCount = {};

  for (const element of arr) {
    if (occurrenceCount[element]) {
      occurrenceCount[element]++;
    } else {
      occurrenceCount[element] = 1;
    }
  }

  return occurrenceCount;
}

const occurrences = countOccurrences(arr);

console.log(occurrences);


step to connect db 

mongosh -u "foogo_user" -p "kjdybh936hyts472fs5r5ygs6tTFRrs578g" --authenticationDatabase "foogo_db"
 
use foogo_db;
show collections;
exit
for admin 

cd /var/www/html/
ls 
cd Admin-Server/
ls 
cd Development/ 

npm i
npm run build
pm2 restart all
timedatectl


mongod query

for update many

db.gamePlays.updateMany( {_id :"655f4c046186c682490f919e",_id  :"655df4edc5a70f6fe3fec78b:},{ $set: { gameStatus: 'completed'}})

db.gamePlays.updateMany(
  {
    _id: {
      $in: [
    ObjectId("655f4c046186c682490f919e"), 
    ObjectId("655df4edc5a70f6fe3fec78b")
]
    }
  },
  { $set: { gameStatus: 'completed' } }
)

for delete one 

db.usersprofiles.deleteOne({ _id: ObjectId("65439a3e62acec07b3fa9891") });

db.gameplays.deleteMany({
  _id: {
    $in: [
      ObjectId("655f4c046186c682490f919e"),
      ObjectId("655df4edc5a70f6fe3fec78b")
    ]
  }
});


db.usersprofiles.deleteMany({
  _id: {
    $in: [
      ObjectId("654cd536f534bb1c8c5a4cd8"),
      ObjectId("654355d0aad14e5cc3116bd0"),
ObjectId("65437e8862acec07b3fa987f")	
    ]
  }
});


cron.schedule('*/1 * * * *', async () => {
    try {
        // Get the current time in the desired format
        const now = new Date();
        const options :any = {
            year: 'numeric',
            month: '2-digit',
            day: '2-digit',
            hour: '2-digit',
            minute: '2-digit'
        };
        const formattedTime = now.toLocaleDateString('en-US', options);

        // Find all games in the database
        const games = await GamePlayModel.find();

        games.forEach(async (game :any) => {
            const startTime = new Date(game.startTime);
            const endTime = new Date(game.endTime);

            if (startTime <= now && now <= endTime) {
                // Update the game status to 'inProgress' if the game is within its time frame
                await GamePlayModel.updateOne({ _id: game._id }, { $set: { gameStatus: 'inProgress' } });
            } else if (now > endTime) {
                // Update the game status to 'completed' if the current time is past the game's end time
                await GamePlayModel.updateOne({ _id: game._id }, { $set: { gameStatus: 'completed' } });
            }
        });

        console.log("Updated game statuses.");

    } catch (err) {
        console.error('Error updating game statuses:', err);
    }
});

for server 

const currentDate' = moment().utc().format("YYYY-MM-DD HH:mm");

for frentend 

moment.utc().local().format('DD/MM/YYYY HH:mm');


cron job -- before replace on server


cron.schedule('*/1 * * * *', async () => {
    try {
        // const currentDate :any = moment().utc().local().format("DD/MM/YYYY, hh:mm A");
        const currentDate :any = moment().utc().local().format("DD/MM/YYYY, hh:mm A");

        console.log("currentDate",currentDate)
        // Find all games in the database
        const games = await GamePlayModel.find();

        games.forEach(async (game :any) => {
            const startTime = (game.startTime);
            const endTime = (game.endTime);
            // console.log("startTime", startTime);
            // console.log("endTime", endTime);
            if (startTime <= currentDate && currentDate <= endTime) {
                // Update the game status to 'inProgress' if the game is within its time frame
                await GamePlayModel.updateOne({ _id: game._id }, { $set: { gameStatus: 'inProgress' } });
            } else if (currentDate > endTime) {
                // Update the game status to 'completed' if the current time is past the game's end time
                await GamePlayModel.updateOne({ _id: game._id }, { $set: { gameStatus: 'completed' } });
            }
        });

        console.log("Updated game statuses.");

    } catch (err) {
        console.error('Error updating game statuses:', err);
    }
});

find the occurance 

function countOccurrences(arr) {
  let occurrences = {};

  arr.forEach((element) => {
    if (occurrences[element]) {
      occurrences[element]++;
    } else {
      occurrences[element] = 1;
    }
  });

 console.log(occurrences)
}
countOccurrences(arr)

{ '1': 3, '2': 2, '3': 3, '4': 1 }

find the duplicates elemnts from the array 

let arr = [1, 2, 3, 1, 2, 3, 1, 3, 4];

const findDuplicatesArray = (arr) => {
    let results = [];
    let sortedArray = arr.slice().sort();

    for (let i = 0; i < sortedArray.length - 1; i++) {
        if (sortedArray[i + 1] === sortedArray[i] && !results.includes(sortedArray[i])) {
            results.push(sortedArray[i]);
        }
    }

    console.log("Unique duplicate elements: ", results);
};

findDuplicatesArray(arr);

o/p = Unique duplicate elements:  [ 1, 2, 3 ]


let arr = [1, 2, 3, 1, 2, 3, 1, 3, 4]
const findDuplicatesArray = (arr)=>{
    
    let results =[];
    let sortedArray = arr.slice().sort();
    for (let i= 0;i<sortedArray.length -1; i++){
        if(sortedArray[i+1]===sortedArray[i]){
            results.push(sortedArray[i])
        }
       
    }
     console.log(results)
     
     
}
findDuplicatesArray(arr)

[ 1, 1, 2, 3, 3 ]

let arr = [1,2,3,6,4,2,1,3]

const findDuplicatesArray=(arr)=>{
    let sortedArray = arr.slice().sort();
    let results = []
    for (let i=0;i<sortedArray.length - 1; i++){
        if (sortedArray[i+1] === sortedArray[i]){
            results.push(sortedArray[i])
        }
    }
    console.log(results)
    
}
findDuplicatesArray(arr)
[ 1, 2, 3 ]


const result = countOccurrences(arr);
console.log(result);


Google login object 

"email": "kumar30895@gmail.com",
    "socialMediaType": "google",
    "socialToken": 'ya29.a0AfB_byB514LDAwuwGJlDe-3OnzAGSmnxAEAqUrFqGTqeg8tjMjj5iZ19hWByCsNH1OWqRYVJ22pO64vyfxKjlfJbzYntVM-62I9FIiSU3SOK5TiinPgCijC4pZ9cHFkaww5UpZG9MojBhCgkPIB10Mr2oN-awnw7-gaCgYKAS8SARASFQHGX2MizV_uaO5_d72J0MC8Yh8SpA0169',
    "socialId": "1p8d8rYPPEOuJoHnnwrBb1lZUsL2",

 "email": "social@game.ca",
  "socialMediaType": "apple",
  "socialToken": "eyJhbGciOiJSUzI1NiIsImtpZCI6ImI0OWM1MDYyZDg5MGY1Y2U0NDllODkwYzg4ZThkZDk4YzRmZWUwYWIiLCJ0eXAiOiJKV1QifQeyJpc3MiOiJodHRwczovL2FjY291bnRzLmdvb2dsZS5jb20iLCJhenAiOiI2NTMwMTgzMjUzNjYtb3FqbTAzNW1jbmpyODFjbTFmbWs2NnI4YjV2YjdrbjUuYXBwcy5nb29nbGV1c2VyY29udGVudC5jb20iLCJhdWQiOiI2NTMwMTgzMjUzNjYtbWVyazNucDdhMWN1aGNjZGthNjBoN3YzZXJoa2hkbmkuYXBwcy5nb29nbGV1c2VyY29udGVudC5jb20iLCJzdWIiOiIxMDQ4MjUxMDA2MDEyNTI1NzcwNjkiLCJlbWFpbCI6InNoYXNoaXJhbmphbjEwN0BnbWFpbC5jb20iLCJlbWFpbF92ZXJpZmllZCI6dHJ1ZSwibmFtZSI6IlNoYXNoaSBTaW5oYSIsInBpY3R1cmUiOiJodHRwczovL2xoMy5nb29nbGV1c2VyY29udGVudC5jb20vYS9BRWRGVHA1LXRLQVNPemoyVDlZNkxvUEpjU1NQQnMwcDNueUhOYkM4Tk9qQjNnPXM5Ni1jIiwiZ2l2ZW5fbmFtZSI6IlNoYXNoaSIsImZhbWlseV9uYW1lIjoiU2luaGEiLCJsb2NhbGUiOiJlbi1HQiIsImlhdCI6MTY3NjM1MDEzNywiZXhwIjoxNjc2MzUzNzM3fQCpIKmoYF3sbV_U1XtknzxszugRaXAxlWrJLTuojn6M1EvBziY-4fxgbYddo-2jg60adqgo8pXLGH2tIRGFRZ9lwvVip_WYU5S_SOZD0-6GpRDqQboJwjz_NemVJbZ0Aot0CjppRIQXJcGWAkbT-XmUmBMRSHwqAGbhd5PKBqjR1hyn-fg0QCh8OVLZVUBaBAgQHXcSIjJuS0earCgcizM0pV4I4klnl4PAZJU8MSd6FKb3Tg7_91bCjl3zbPJJCkJpHcVGErBxuhTSjPK2fR5Ols8uG0F-x5-6Fl8jLoOOG1rBs2Tf5s_eMPqxv6bu11pjkpCwL9EMM6msorO",
  "socialId": "110341046618429680831",


for marekt desk

pm2 start bin/www --name "backend"

pm2 delete all




 foogo 
PORT =4092
  REACT_APP_BASE_URL=https://api.dev.foogo.io // client api url
  REACT_APP_BASE_URL=https://api.foogo.flexsin.org //stagging api url 
  # REACT_APP_BASE_URL=http://localhost:4091


let x= 5;
let y = "6";

let result = x+y ;
console.log(typeof (result));

console.log("A"-"B")
console.log("2" - "2" +2)

console.log(!!0)
console.log(!1)

How to Compare Two Objects in Javascript

const obj1 = {"a": 1, "b": 2};
const obj2 = {"a": 1, "b": 2};

console.log(JSON.stringify(obj1) === JSON.stringify(obj2)); // true

const obj1 = {"a": 1, "b": 2};
const obj2 = {"b": 2, "a": 1};

console.log(JSON.stringify(obj1) === JSON.stringify(obj2)); // false

explain pure functions 
https://www.freecodecamp.org/news/what-is-a-pure-function-in-javascript-acb887375dfe/
https://www.geeksforgeeks.org/pure-functions-in-javascript
https://www.scaler.com/topics/pure-function-in-javascript/

A Pure Function is a function (a block of code) that always returns the same result if the same arguments are passed. 
It does not depend on any state or data change during a program’s execution. Rather, it only depends on its input arguments.

Also, a pure function does not produce any observable side effects such as network requests or data mutation, etc.

ex 
// Pure function example
function add(a, b) {
  return a + b;
}

// Using the pure function
console.log(add(2, 3)); // Output: 5
console.log(add(2, 3)); // Output: 5

Explain Impure function

Impure functions in JavaScript are functions that produce side effects or rely on external factors, such as modifying variables outside of their scope, 
interacting with the DOM, making network requests, or accessing external state. Unlike pure functions, 
impure functions can produce different results for the same input because they are not solely determined by their arguments.

// Impure function example
let globalVariable = 0;

function impureAdd(num) {
  globalVariable += num; // Modifies external state
  return globalVariable;
}

console.log(impureAdd(5)); // Output: 5
console.log(impureAdd(3)); // Output: 8



Lexical scoping in JavaScript
JavaScript uses lexical scoping to resolve the variable names when a function is created inside another function. 
It determines the function's parent scope by looking at where the function was created instead of where it was invoked.

var a = 10
var func = function (){
var b = 20;
    console.log("a and b is accessible (outer):", a, b);
    var innerFunc= function (){
        var c = 30;
        console.log("a and b and c is accessible (inner):", a, b, c);
    }
    innerFunc();
    return;
}
func();
console.log("only a is accessible (global):", a);

output based questions link

https://developersthoughtworld.blogspot.com/2023/03/javascript-logical-output-based-interview-questions.html?lr=1
https://github.com/lydiahallie/javascript-questions
https://medium.com/@utkarsh.gupta0311/javascript-output-questions-to-test-your-skills-7fcc06ecd117
https://www.codewhoop.com/blog/javascript/javascript-interview-output-questions-and-answers-101.html
https://www.fullstack.cafe/blog/javascript-code-interview-questions
https://www.keka.com/javascript-coding-interview-questions-and-answers


Var arr = [2, 4, 5, 2, 8, 1, 6, 3];


4+5 = 9 // 4 and 5

All pairs whose sum should be equal to 9

4 and 5, 8 and 1,  6 and 3

company name -impetus technlogy.


import React, { useState, useRef } from 'react';

function App() {
  const [count, setCount] = useState(0);
  const intervalRef = useRef(null);

  const start = () => {
    intervalRef.current = setInterval(() => {
      setCount((prevCount) => prevCount + 1);
    }, 1000); 
  };

  const stop = () => {
    clearInterval(intervalRef.current);
  };

  const reset = () => {
    clearInterval(intervalRef.current);
    setCount(0);
  };

  return (
    <>
      <h1>Count: {count}</h1>
      <button onClick={start}>Start</button>
      <button onClick={stop}>Stop</button>
      <button onClick={reset}>Reset</button>
    </>
  );
}

export default App;

input= "aim sound"

o/p- "mia dnuos"
function reverseWords(input) {
  // Split the input string into an array of words
  const words = input.split(' ');

  // Map over each word and reverse it
  const reversedWords = words.map(word => {
    // Split the word into an array of characters, reverse it, and join it back together
    return word.split('').reverse().join('');
  });

  // Join the reversed words back together with spaces and return the result
  return reversedWords.join(' ');
}

const input = "aim sound";
const output = reverseWords(input);
console.log(output); // Output: "mia dnuos"













